\documentclass{article}
\usepackage{graphicx}
\usepackage{chngcntr}
\usepackage{float}
\usepackage{hyperref}
\counterwithin{figure}{section}

\title{Hop-Tales}
\author{Enrico Casadei, 
\texttt{enrico.casadei18@studio.unibo.it}
\and
Simone Capacci,
\texttt{simone.capacci3@studio.unibo.it}
\and
Simone Gentili,
\texttt{simone.gentili4@studio.unibo.it}
\and
Eleonora Bartoletti,
\texttt{eleonora.bartoletti2@studio.unibo.it}
}
\date{February 2026}

\renewcommand{\contentsname}{Indice}

\begin{document}

\maketitle

\newpage

\tableofcontents

\section{Analisi}
\subsection{Descrizione e requisiti}
Il gruppo si pone come obiettivo la realizzazione di un gioco platformer chiamato Hop-Tales. Il gioco si sviluppa in 3 livelli: nel primo il giocatore si muove in avanti evitando i nemici fino a raggiungere un castello posto alla fine del livello; nel secondo livello, simile al primo, si utilizza un secondo personaggio che a fine livello raggiunge lo stesso castello; nel terzo livello, da giocare in due, il gioco diventa un puzzle-platformer, in cui i due personaggi devono risolvere dei mini-puzzle per finalmente riunirsi.
\paragraph{Requisiti funzionali}
\begin{itemize}
    \item Il giocatore sarà in grado di muoversi liberamente su due dimensioni per tutti e tre i livelli.
    \item I primi due livelli avranno lo stesso stile da classico platformer, in cui il giocatore procede verso una direzione finchè non completa il livello, mentre il terzo livello sarà composto da una stanza predefinita contenente dei puzzle.
    \item Il giocatore avrà la possibilità di interagire con diversi elementi del livello che avranno particolari effetti; in particolare nei primi due livelli forniranno un potenziamento al personaggio, mentre nel terzo livello permetteranno di risolvere i puzzle al fine di completare il livello.
    \item Tra gli elementi interagibili nei vari livelli ci saranno anche le monete, oggetti raccoglibili che potranno essere utilizzati nel menù per fini puramente decorativi.
    \item Sarà presente un menù principale da cui saranno accessibili i vari livelli oltre allo shop, in cui si potranno spendere le monete raccolte per comprare delle skin per i personaggi, e alle impostazioni, che riguarderanno principalmente effetti audio.
    \item Saranno presenti diversi tipi di nemici in grado di ostacolare il giocatore. Essi avranno anche la possibilità di "terminare" la partita, colpendo il giocatore un certo numero di volte.    
\end{itemize}
\paragraph{Requisiti non funzionali}
\begin{itemize}
    \item Il gioco dovrà funzionare senza errori su diversi sistemi operativi, tra cui sicuramente una qualsiasi distribuzione Linux. 
\end{itemize}
\subsection{Modello del Dominio}
All'avvio del gioco si crea una finestra dove viene mostrato il menù principale, 
da cui il giocatore può scegliere di aprire lo shop (per comprare delle skin per i 
personaggi), le opzioni (per modificare gli effetti audio) o giocare. Scegliendo 
l'ultima opzione a sua volta gli verrà chiesto quale livello vuole affrontare.
In seguito la finestra mostrerà il livello selezionato e all'interno di esso si 
troveranno diversi elementi: ovviamente ci sarà il personaggio del giocatore, 
in grado di muoversi liberamente e saltare, inoltre saranno presenti dei nemici, 
anch'essi in grado di muoversi (anche se in maniera predefinita). Il giocatore 
presenta i punti vita, ovvero un indice numerico che si abbassa ogni volta che 
l'entità subisce danni. Qualora l'indice scenda a 0 o inferiore finisce la partita. 
Il giocatore inoltre avrà la possibilità di raccogliere dei "Power-up", che gli 
permetteranno di non subire danni la prossima volta che verrà colpito. 
Oltre alle entità saranno presenti oggetti che avranno caratteristiche diverse 
tra di loro. Tutti gli oggetti hanno un determinato comportamento quando vengono 
toccati in base al tipo. Gli elementi sopracitati con le loro relazioni sono 
riassunti nella Figura~\ref{fig:uml_analisi}. 
\begin{figure}[H]
    \centering
    \includegraphics[width=10cm]{Level System and Shop Flow-2026-02-08-164651.png}
    \caption{Diagramma UML dell'analisi del dominio}
    \label{fig:uml_analisi}
\end{figure}

\section{Design}
\subsection{Architettura}

Considerando che il gioco è diviso in due sezioni decisamente diverse, ovvero la parte del menù e quella della partita, si è optato per dividere la struttura architetturale del gioco in due blocchi. Per l'architettura del menu di gioco si sfrutta una variante semplificata del pattern MVC. Lo stato del menu è infatti gestito implicitamente dal Controller, che decide quale schermata visualizzare in base agli input ricevuti.
 All'avvio del gioco viene creato il Menu, che rappresenta la \textit{View} principale. Esso riceve gli input attraverso cui notifica il MenuController, che rappresenta il \textit{Controller}, il quale gestisce i vari stati del menu che vengono modificati in base agli input dell' user. Ogni volta che si verifica il cambiamento di stato (ovvero l'utente seleziona la schermata interessata) Il MenuController si attiva chiamando direttamente la view mostrando dunque la schermata corretta. Per passare al secondo caso d'uso, ovvero lo stato di gioco vero e proprio, serve l'input del giocatore per avviare un livello, in modo tale che il Menu lo riceva, avvisi il MenuController e quest'ultimo permetta di accedere alla partita.
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{Duck beakColor Taxonomy Flow-2026-02-09-112200.png}
    \caption{Diagramma UML dell'architettura del sistema}
    \label{fig:uml_design}
\end{figure}

\subsection{Design dettagliato}
\subsubsection{Capacci Simone}
\paragraph{Caricamento dei livelli tramite DTO, Mapper e Factory}
\par
\paragraph{Problema :}
Il gioco deve caricare i livelli da file esterni, descritti tramite una
rappresentazione persistente (file JSON).
Era necessario evitare che il modello di gioco dipendesse direttamente dalla
struttura dei file. Inoltre, il sistema deve permettere l’aggiunta di nuovi
livelli senza richiedere modifiche al codice del modello.


\paragraph{Soluzione :}
La soluzione adottata consente di utilizzare più file JSON per definire livelli
differenti, permettendo l’aggiunta di nuovi livelli in futuro senza modificare il
modello di gioco.

I file di livello vengono deserializzati dalla classe \textit{LevelLoader}, che produce
strutture dati intermedie prive di logica (\textit{LevelData}, \textit{EntityData},
\textit{MacroData}). Tali classi svolgono il ruolo di DTO (Data Transfer Object) e
rappresentano esclusivamente i dati necessari al trasferimento delle informazioni.

\paragraph{Pattern usato :} \textit{DTO} (Data Transfer Object)\newline 
Un DTO è un oggetto che contiene solo dati, senza logica applicativa, ed è
utilizzato per trasferire informazioni tra diversi strati dell’applicazione,
mantenendo il modello indipendente dai dettagli di persistenza.

La conversione dai DTO agli oggetti del dominio è demandata a un componente
dedicato, \textit{EntityFactory} (\textit{Factory Method}), che si occupa di istanziare le corrette entità di gioco
a partire dai dati deserializzati, cosi che la logica di conversione è centralizzata in un
unico punto.

Il \textit{GameController} coordina il processo di caricamento utilizzando i DTO e il mapper
per inizializzare lo stato del mondo di gioco.
\paragraph{Pattern usati :} \textit{Factory Method}, \textit{Mapper}.\newline
Il Factory Method centralizza la creazione degli oggetti, nascondendo al
chiamante le classi concrete utilizzate.

Il Mapper si occupa di convertire dati da una rappresentazione a
un’altra, tipicamente da oggetti di trasferimento (DTO) a oggetti del dominio,
mantenendo separata la logica di conversione dal modello.

\paragraph{Motivazione :}
Questa soluzione permette di mantenere il modello indipendente, centralizzare la logica di creazione delle entità, facilitare l’estensione del sistema con nuovi tipi di entità o nuovi
formati di livello.
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{level_loading.png}
    \caption{Diagramma UML del caricamento dei livelli tramite DTO e Factory}
    \label{fig:uml-level-loading}
\end{figure}

\paragraph{Gestione degli stati dell’applicazione}
\par
\paragraph{Problema :}
L’applicazione presenta diverse modalità operative (menu principale, selezione del
livello, negozio, opzioni e gioco), che devono essere gestite in modo coerente e
esclusivo.
Una gestione basata su condizioni sparse avrebbe reso il sistema
difficile da estendere e manutenere.

\paragraph{Soluzione :}
Gli stati dell’applicazione sono rappresentati tramite un’enumerazione (State)
che descrive in modo esplicito tutte le modalità operative.
Il \textit{ControllerMenu} utilizza tale rappresentazione per gestire le transizioni tra
gli stati e decidere quale componente della view visualizzare.

\paragraph{Pattern usato :} \textit{State} (variante semplificata basata su enumerazioni)
gli stati dell’applicazione sono rappresentati tramite
un’enumerazione che rende esplicite le modalità operative possibili e consente
al controller di gestire in modo centralizzato le transizioni tra gli stati.

\paragraph{Motivazioni:}
Si rendono espliciti gli stati dell’applicazione, centralizza la gestione delle transizioni e si semplifica l'aggiunta di nuove modalità operative.
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{menu_state.png}
    \caption{Diagramma UML della gestione degli stati dell'applicazione}
    \label{fig:uml-menu-state}
\end{figure}
\paragraph{Gestione delle animazioni e delle risorse grafiche}
\par
\paragraph{Problema :}
Le entità di gioco richiedono animazioni basate su sequenze di immagini e una
gestione efficiente delle risorse grafiche.
Una gestione diretta delle immagini all’interno delle singole entità come inizialmente pensato avrebbe
portato a duplicazione di codice e spreco di risorse.

\paragraph{Soluzione :}
La gestione delle animazioni è separata dalla gestione delle risorse grafiche:
la classe \textit{Animation} incapsula la logica temporale dei frame, mentre \textit{Draw} 
delega ad \textit{Animation} la selezione del frame corretto da visualizzare.
Il caricamento e il caching delle immagini sono centralizzati nella classe
\textit{Draw}(\textit{Factory}), che evita il caricamento ripetuto delle stesse risorse grafiche.

\paragraph{Pattern usati :} \textit{Factory}(per la creazione e gestione delle risorse)

\paragraph{Motivazione :}
Riduce la duplicazione del codice e migliora le prestazioni tramite caching;

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{Draw.png}
    \caption{Diagramma gestione animazioni e risorse grafiche}
    \label{fig:uml-draw}
\end{figure}


\subsubsection{Bartoletti Eleonora}

\paragraph{Gestione del Livello 3 (mappa, entità, interazioni)}
\par
\paragraph{Problema :}
Il livello 3 richiede una mappa complessa con oggetti eterogenei (porte, massi, pulsanti, piattaforme mobili, teletrasporti) e una logica fisica specifica (gravità, collisioni, teletrasporto, interazioni con porte e pulsanti). È necessario mantenere il pattern MVC e non intrecciare il rendering con la logica di gioco.

\paragraph{Soluzione adottata :}
\begin{itemize}
  \item Model: \textit{LevelModel} mantiene lo stato del livello (mappa, entità, immagini, associazioni logiche).
  \item Controller: \textit{LevelLogic} esegue il tick di gioco, gestendo input, fisica, interazioni e condizioni di vittoria/sconfitta.
  \item View: \textit{FireboyWatergirlLevel} + \textit{LevelRenderer} mostrano la scena e delegano la logica al controller.
\end{itemize}

Le associazioni “porta–pulsante” e “teletrasporto–destinazione” vengono costruite una sola volta da `LevelBuilder` usando funzioni di mapping tra tile e oggetti.

\paragraph{Alternative considerate :}
\begin{itemize}
  \item God class unica che gestisce rendering e logica: scartata perché infrange MVC e rende difficile isolare bug.
  \item Ogni oggetto con logica autonoma (porte, pulsanti, teleporters autogestiti): scartata per eccessiva frammentazione e difficoltà di coordinamento temporale (tick unico).
\end{itemize}

\paragraph{Pro/Contro :}
\begin{itemize}
  \item Pro : separazione netta di responsabilità, logica testabile, rendering sostituibile.
  \item Contro : più classi e passaggi di dati (model-controller-view) rispetto a una soluzione monolitica.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=8cm]{Figure1Bartoletti.png}
    \caption{Vista d’insieme del design del Livello 3 (MVC) con costruzione iniziale delle entità.}
    \label{fig:uml_design_1}
\end{figure}

\paragraph{Pattern utilizzati :}
\begin{itemize}
  \item \textit{Template Method} (variante leggera): \textit{AbstractWorldEntity} definisce l’interfaccia comune `draw(...)` e fornisce il metodo condiviso `drawTiled(...)`. Le entità (Boulder, Door, MovingPlatform) specializzano il comportamento grafico. È una forma di \textit{Template Method}: la “struttura” della renderizzazione è fornita dalla superclasse e le sottoclassi completano il comportamento.
\end{itemize}

\paragraph{Associazioni logiche (porte, pulsanti, teleport)}

\paragraph{Problema :}
Nella mappa del livello 3 esistono oggetti che devono essere collegati logicamente: pulsanti che aprono porte , teleport che portano a specifiche coordinate.  
Il collegamento non può essere hardcoded nella logica del controller.

\paragraph{Soluzione adottata :}
Nel \textit{LevelBuilder} si costruiscono mappe:
\begin{itemize}
  \item `buttonToDoorId`: associazione tile–id porta
  \item `teleportDestTile`: associazione tile–destinazione
\end{itemize}
Queste strutture vengono poi usate da `LevelInteractions` durante il runtime.

\paragraph{Alternative considerate :}
\begin{itemize}
  \item Hardcode nel controller: scartato per bassa manutenibilità.
  \item Configurazione esterna (JSON): scartata per evitare modifiche strutturali al progetto.
\end{itemize}

\paragraph{Pro/Contro:}
\begin{itemize}
  \item Pro : maggiore chiarezza, logica separata e riutilizzabile.
  \item Contro : aggiunta di step di build (ma una tantum).
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=8cm]{Figure2Bartoletti.png}
    \caption{Associazioni logiche nel Livello 3: mapping tra pulsanti, porte e teletrasporti.}
    \label{fig:uml_design_2}
\end{figure}

\paragraph{Pattern utilizzato :}
\begin{itemize}
  \item Separazione delle responsabilità: \textit{LevelInteractions} centralizza le interazioni (porte, teleport) mantenendo la logica di movimento in \textit{LevelLogic} e il rendering nella view.
\end{itemize}


\paragraph{Persistenza monete e skin (CoinStorage)}
\par
\paragraph{Problema :}
Le monete raccolte e le skin acquistate devono essere persistenti fra sessioni. È necessario leggere e scrivere su file evitando duplicazioni e mantenendo compatibilità con l’economia del gioco.

\paragraph{Soluzione adottata:}
\textit{CoinStorage} centralizza:
\begin{itemize}
  \item conteggio monete
  \item lettura/scrittura su `coins.txt`
  \item stato di acquisto delle skin (0/1)
\end{itemize}
Lo stato viene caricato all’avvio e aggiornato dopo ogni acquisto/collezione.

\paragraph{Alternative considerate :}
\begin{itemize}
  \item Scrivere file separati: scartato per maggiore complessità.
  \item Salvataggio in JSON: scartato per non introdurre dipendenze extra e mantenere semplicità.
\end{itemize}

\paragraph{Pro/Contro :}
\begin{itemize}
  \item Pro: persistenza stabile, file unico e facile da ispezionare.
  \item Contro: struttura rigida (3 righe per skin, ordine fisso).
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=8cm]{Figure3Bartoletti.png}
    \caption{Gestione persistente delle risorse di gioco (monete e skin) e loro integrazione con lo shop.}
    \label{fig:uml_design_3}
\end{figure}

\subsubsection{Gentili Simone}
\paragraph{Struttura base dei nemici}
\par

\paragraph{Problema :} I nemici presenti nel gioco appartengono a tipologie diverse, ma condividono la stessa struttura di base e gran parte del comportamento. 
Questo portava alla creazione di classi molto simili tra loro, con duplicazione di codice e difficoltà di manutenzione.

\paragraph{Soluzione :} Per risolvere il problema è stato utilizzato il \textit{pattern Template Method}. È stata introdotta una classe astratta \textit{AbstractEnemyImpl} 
che definisce lo scheletro comune del comportamento dei nemici. Il metodo template è \textbf{update()} 
che stabilisce l’ordine fisso delle operazioni di aggiornamento (movimento orizzontale, salto e gravità).
La personalizzazione del comportamento avviene tramite:

\begin{itemize}
    \item il metodo astratto \textbf{getSpeed()}, obbligatorio per ogni sottoclasse
    \item i metodi hook \textbf{moveHorizontalStep()}, \textbf{jumpStep()} e \textbf{gravityStep()} che possono essere sovrascritti dalle sottoclassi
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{AbstracEnemy_template.png}
    \caption{Diagramma UML della struttura dei nemici}
    \label{fig:uml_AbstractEnemy_structure}
\end{figure}

Grazie a questa struttura l’aggiunta di un nuovo tipo o la modica delle specifiche di movimento di un enemy è molto semplice e di facile manutenzione.

\paragraph{Creazione dei nemici}
\par
\paragraph{Problema :} 
Nel gioco esistono diversi tipi di nemici, ciascuno con comportamenti e caratteristiche specifiche, 
che devono essere inseriti nei livelli in posizioni precise. Senza una gestione centralizzata la creazione di ogni nemico comporterebbe 
la duplicazione di codice e un aumento delle dipendenze tra classi, rendendo difficile la manutenzione.

\paragraph{Soluzione :} 
Per risolvere il problema è stato utilizzato il \textit{pattern Factory Method}. È stata introdotta la classe \textbf{EnemyFactory}, 
responsabile della creazione degli oggetti \textit{Enemy}. La factory decide quale implementazione concreta istanziare in base al tipo di nemico, 
definito dalla classe di tipo ENUM \textbf{EnemyType}, restituendo sempre un riferimento all’interfaccia \textit{Enemy}. In questo modo la logica di creazione è centralizzata e le dipendenze dalle classi sono ridotte. 
Questo comporta: 

\begin{itemize}
    \item una facilità d’uso; quando c’è bisogno di creare un nemico basta richiamare il metodo \textbf{createEnemy()} della factory.
    \item la logica di creazione dei nemici è centralizzata nella factory, evitando che altre classi debbano conoscere i dettagli delle implementazioni concrete.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{EnemyFactory.png}
    \caption{Diagramma UML della creazione dei nemici}
    \label{fig:uml_EnemyFactory}
\end{figure}

La \textbf{EnemyFactory} rimane separata dalla (\textbf{EntityFactory}) perché i nemici e le entità statiche hanno logiche diversi; 
se fosse unita violerebbe il \textit{Single Responsibility Principle} e renderebbe il codice più difficile da mantenere ed estendere.  

\subsubsection{Casadei Enrico}
\paragraph{Gestione del controller in fase di gioco}
\par
\paragraph{Problema :}  Nella fase di gioco la parte implementativa legata al Model è piuttosto corposa, di conseguenza la logica per ogni update chiamato dal Controller potrebbe creare delle classi troppo grandi con molti compiti diversi.

\paragraph{Soluzione :}  Suddivisione della parte del Controller legata alla fase di gioco in più classi, seguendo l' \textit{Observer pattern}.
La classe GameController sarà \textit{Observable}, mentre le classi PlayerController, EnemyController e CollectablesController saranno gli \textit{Observers}. Il GameController si serve di un Timer che richiama ad una certa frequenza il metodo del GameController che notifica gli \textit{Observers}. Questi ultimi quindi richiamano l'update della parte del Model che li riguarda. 
Per il PlayerController ho preferito gestire la logica al suo interno per non appesantire troppo la classe del Player, mentre per il CollectablesController mi sono servito di una classe helper comune ai vari \textit{Collectables} chiamata CollectableManager. La realizzazione è riassunta in Figura~\ref{fig:uml_controller}.
\begin{figure}[H]
    \centering
    \includegraphics[width=10cm]{ControllerHandling.png}
    \caption{Diagramma UML del pattern \textit{Observer} utilizzato per la rappresentazione del Controller}
    \label{fig:uml_controller}
\end{figure}
\paragraph{Gestione delle collisioni}
\par
\paragraph{Problema :} Bisogna gestire ogni tipo di collisione, in maniera comprensibile e facile da riutilizzare in diverse situazioni.

\paragraph{Soluzione :} Creazione della classe Collider che gestisce al suo interno tutta la logica che riguarda il controllo delle possibili collisioni, rendendo l'utilizzo dei suoi metodi veloce ed intuitivo. La classe sfrutta il pattern \textit{Facade}, in quanto fornisce alle altre classi un'interfaccia semplice tramite i propri metodi, nascondendo la logica implementativa. La realizzazione è riassunta in Figura~\ref{fig:uml_collider}.
\begin{figure}[H]
    \centering
    \includegraphics[width=10cm]{ColliderDiagram.png}
    \caption{Diagramma UML del Collider e delle classi con cui interagisce}
    \label{fig:uml_collider}
\end{figure}
\paragraph{Gestione degli effetti sonori}
\par
\paragraph{Problema :} Serve una funzionalità in grado di manipolare in modo semplice e intuitivo i vari file audio presenti nel gioco.

\paragraph{Soluzione :} Sviluppo della utility class AudioManager, che anch'essa sfrutta il pattern \textit{Facade} per offrire una interfacciabilità comoda tramite i propri metodi statici. La classe si serve della libreria \textit{javax.sound.sampled} per implementare pochi ma efficienti metodi per il progetto. La realizzazione è riassunta in Figura~\ref{fig:uml_audiomanager}.
\begin{figure}[H]
    \centering
    \includegraphics[width=12cm]{AudioManagerDiagram.png}
    \caption{Diagramma UML del pattern \textit{Facade} utilizzato per AudioManager}
    \label{fig:uml_audiomanager}
\end{figure}
\paragraph{Implementazione del Player}
\par
\paragraph{Problema :} Necessità di creare la classe che gestisce il giocatore, rendendola semplice e possibilmente modificabile per eventuali cambiamenti futuri.

\paragraph{Soluzione :} Sfruttare il pattern \textit{Strategy} per creare una gerarchia
di classi utilizzabili in contesti diversi che non richiedono di conoscere 
l'implementazione. In questo caso si ha una interfaccia generale Entity, sfruttata
anche per l'implementazione dei nemici, e una interfaccia Player che la estende 
e viene implementata da PlayerImpl, per rendere più semplici eventuali implementazioni 
future più complesse. La classe PlayerImpl inoltre, come spiegato in precedenza, 
delega alla classe PlayerController la logica di aggiornamento del proprio stato,
per ridurre la propria complessità. La realizzazione è riassunta in Figura~\ref{fig:uml_player}.
\begin{figure}[H]
    \centering
    \includegraphics[width=3cm]{PlayerDiagram.png}
    \caption{Diagramma UML del pattern \textit{Strategy} utilizzato per Entity, Player e PlayerImpl}
    \label{fig:uml_player}
\end{figure}

\section{Sviluppo}
\subsection{Testing automatizzato}

Il testing automatico serve per evitare regressioni e garantire che le funzionalità principali rimangano corrette dopo ogni modifica.  
Nel progetto sono stati adottati test completamente automatici basati su JUnit, senza intervento umano.
I test coprono in modo minimale ma significativo:

\begin{itemize}
  \item \textbf{Enemy}: nel quale viene testato il corretto movimento dei nemici, la corretta creazione dei tipi di nemici nel livello.
  \item \textbf{Player}: nel quale viene testate le interazioni del player con i powerup e il danno subito.
  \item \textbf{Livello 3}: testiamo che la mappa venga caricata correttamente, 
  che le entità principali vengano create (porte, massi, bottoni, teleport, piattaforme) e che le associazioni logiche (pulsante--porta, teleport--destinazione) siano consistenti con le costanti di gioco.
  \item \textbf{Map}: nel quale viene testata il corretto caricamento delle mappe dei livelli 1 e 2, 
  creazione delle entita al suo interno e delle interazioni nel world.
  \item \textbf{CoinStorage}: testiamo la lettura/scrittura da file, 
  verificando il caricamento delle monete e dei flag di acquisto delle skin e la persistenza di un acquisto.
  \item \textbf{Collider}: nel quale viene testata le collisioni con nemici, powerup, monete, blocchi solidi e blocchi hazard.
  \item \textbf{AudioManager}: nel quale viene testato il corretto funzionamento dei metodi.
  \item \textbf{GameController e PlayerController}: viene testata la chiamata dei metodi update e il corretto funzionamento della logica legata al Player   .
\end{itemize}

\subsection{Note di sviluppo}
\subsubsection{Capacci Simone}
\paragraph{Uso di librerie di terze parti}
usati in :
\begin{sloppypar}
  \url{https://github.com/burraco04/OOP25-hop-tales/blob/a4aaf040e954816289de773d2bdcfe55a6639e04/src/main/java/deserialization/level/LevelLoader.java#L8}
\end{sloppypar}
\paragraph{Uso di method reference :}
\begin{sloppypar}
  \url{https://github.com/burraco04/OOP25-hop-tales/blob/a4aaf040e954816289de773d2bdcfe55a6639e04/src/main/java/view/utils/Draw.java#L39C2-L39C61}
\end{sloppypar}

\paragraph{parte di codice riadattata da internet}
FontFactory.

\subsubsection{Bartoletti Eleonora}

\paragraph{Feature avanzate Java utilizzate (con esempi di codice):}
\begin{itemize}
  \item Lambdas e interfacce funzionali: uso di `BiFunction`, `BiConsumer` e funzioni lambda per costruire associazioni (porte, bottoni, teletrasporti) in modo dichiarativo, riducendo duplicazioni e migliorando la leggibilità.  
  \begin{sloppypar}
  \url{https://github.com/burraco04/OOP25-hop-tales/blob/bff6094f7ce7ab1c8f222baf7a095938b35ef692/src/main/java/model/level/LevelBuilder.java#L186}
  \end{sloppypar}
  \item Method reference: impiego di `AbstractWorldEntity::getX` per ordinare le piattaforme in modo conciso e type-safe.  
   \begin{sloppypar}
  \url{https://github.com/burraco04/OOP25-hop-tales/blob/bff6094f7ce7ab1c8f222baf7a095938b35ef692/src/main/java/model/level/LevelBuilder.java#L134}
  \end{sloppypar}
  \item Generics con collezioni e comparator tipizzati: uso di `List`, `Map`, `Comparator` e `Deque` con tipi concreti per garantire sicurezza a compile-time e semplificare la logica del builder. 
  \begin{sloppypar}
  \url{https://github.com/burraco04/OOP25-hop-tales/blob/bff6094f7ce7ab1c8f222baf7a095938b35ef692/src/main/java/model/level/LevelBuilder.java#L26}
  \end{sloppypar}

  \item Annotazioni di terze parti (SpotBugs): utilizzo di `@SuppressFBWarnings` per documentare e controllare esposizioni intenzionali di riferimenti live nel modello MVC.  
  \begin{sloppypar}
  \url{https://github.com/burraco04/OOP25-hop-tales/blob/bff6094f7ce7ab1c8f222baf7a095938b35ef692/src/main/java/model/level/LevelModel.java#L18}
  \end{sloppypar}
  \item Graphics2D e trasformazioni affini (JDK avanzato): uso di `Graphics2D` e `AffineTransform` per gestire scaling e offset della scena in modo robusto e indipendente dalla risoluzione.  
  \begin{sloppypar}
  \url{https://github.com/burraco04/OOP25-hop-tales/blob/bff6094f7ce7ab1c8f222baf7a095938b35ef692/src/main/java/view/impl/LevelRenderer.java#L28}
\end{sloppypar}
\end{itemize}

\paragraph{Codice riadattato o preso da fonti esterne}
Nessun codice copiato integralmente da risorse esterne. Le scelte di implementazione per il livello 3 sono originali; eventuali ispirazioni generali (es. gestione del loop di gioco) derivano da conoscenze pregresse e documentazione standard Java/Swing.

\subsubsection{Gentili Simone}
\paragraph{Uso di lambda expressions}
utilizzati ad esempio in :
\begin{sloppypar}
  \url{https://github.com/burraco04/OOP25-hop-tales/blob/e8d6cd9bf68d214d4bf5f25293e49066bc76d247/src/main/java/controller/impl/EnemyController.java#L31}
\end{sloppypar}

\subsubsection{Casadei Enrico}
\paragraph{Uso di lambda expressions :}
\begin{sloppypar}
  \url{https://github.com/burraco04/OOP25-hop-tales/blob/6daf410c5458683661c141251516f26d5f0a6975/src/main/java/view/api/AbstractResultPanel.java#L44}
\end{sloppypar}
\paragraph{Uso di \textit{javax.sound.sampled} per gestione audio in :}
\begin{sloppypar}
  \url{https://github.com/burraco04/OOP25-hop-tales/blob/6daf410c5458683661c141251516f26d5f0a6975/src/main/java/controller/AudioManager.java#L21}
\end{sloppypar}

\section{Commenti finali}
\subsection{Autovalutazione e lavori futuri}
\subsubsection{Capacci Simone}
All’interno del gruppo mi sono occupato principalmente della progettazione
e dell’implementazione delle componenti legate al caricamento dei livelli primo e secondo,
 In particolare la creazione di tiles e della struttura intera della mappa relativa al primo livello.
alla gestione delle risorse grafiche e delle animazioni, nonché di
parti legate interfaccia utente (menu , negozio(creazione di skin e possibilità di comprarle), opzioni).

Non sono completamente soddisfatto del mio lavoro in quanto per mancanza di tempo non sono riuscito a modellare lo shop e la gestione skin. Nonostante ciò, penso sia stata un ottima esperienza formativa che mi ha permesso di consolidare e migliorare le mie competenze di programmazione.

\subsubsection{Bartoletti Eleonora}
La realizzazione di questo progetto per me è stata rivelatrice: in particolare, mi ha aiutato a capire che il lavoro di gruppo è fondamentale, 
e che lo sarà sempre di più nel mondo del lavoro. Mi è servito a realizzare che il teamworking è una cosa su cui devo ancora lavorare, 
ma sono convinta di essere nella giusta strada. Un gruppo unito e che si aiuta a vicenda ha sicuramente una riuscita migliore del lavoro del singolo. 
Detto questo, ritengo che il gruppo nella totalità abbia lavorato molto bene, nonostante le normali e, molte volte necessarie, divergenze riguardo il da farsi.

\subsubsection{Gentili Simone}
Mi sono occupato principalmente della progettazione dei nemici, della loro corretta creazione e movimento all’interno dei livello 1 e 2.
Ho inoltre lavorato alla totale struttura del livello 2 con i propri oggetti e alla corretta visione del player e degli oggetti all’interno dei primi due livelli durante la fase di gioco. 
Con questo progetto ho capito che gran parte del lavoro non è solo progettare ma è avere una buona organizzazione con il resto del team. 
Avrei voluto esplorare di più su diversi nemici ma mi ritengo comunque soddisfatto di aver fatto questa esperienza sicuramente in un futuro lavorativo.


\subsubsection{Casadei Enrico}
La mia parte riguardava la gestione del giocatore, della logica delle collisioni e della gestione degli effetti sonori. Inoltre mi sono occuppato dello sviluppo della parte del Controller legata alla fase di gioco.
Purtroppo non mi sento soddisfatto di come ho lavorato. Lavorare in gruppo è stata sicuramente un'esperienza formativa e utile per
il futuro ma anche molto impegnativa, causando così difficoltà nella realizzazione del progetto e nel rispetto delle scadenze.

\clearpage
\section*{Guida Utente}
\addcontentsline{toc}{section}{Guida Utente}
Il gioco una volta aperto avrà una scermata principale menu dalla quale si potra andare nella sezione dei livelli, delle opzioni e dello shop, 
una volta entrati in start e selezionato un livello si potra muovere il player premendo : 
\begin{itemize}
    \item \textbf{A} per muoverlo a sinistra
    \item \textbf{D} per muoverlo a destra
    \item \textbf{W} oppure \textbf{barra spaziatrice} per saltare (se tenuto premuto continua a saltare ogni volta che tocca un blocco solido)
    \item \textbf{S} per cadere più velocemente (Solo quando si è in aria)
\end{itemize}  
Una volta raggiunta la porta a fine livello 1 e 2 si potrsa preme : \textbf{E} per tornale al menu principale.
Invece nel livello 3 si potrà muovere due player uno utilizzando
\begin{itemize}
    \item \textbf{A} per muoverlo a sinistra
    \item \textbf{D} per muoverlo a destra
    \item \textbf{W} per saltare
\end{itemize} 
e l'altro player userà \begin{itemize}
    \item \textbf{freccia →} per muoverlo a sinistra
    \item \textbf{freccia ←} per muoverlo a destra
    \item \textbf{freccia ↑} per saltare
\end{itemize} 
Una volta che entrambi i player saranno arrivati alla porta finale si potrà premere : \textbf{R} per riprovare il livello obbure : \textbf{H} per tornale al menu principale.
\end{document}
